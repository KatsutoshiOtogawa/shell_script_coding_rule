# シニアエンジニアのためのbashコーディング規約

---

title: シニアエンジニアのためのbashコーディング規約
author: KatusothiOtogawa
date: 2022-03-19

---

## 自己紹介

音川 勝俊 \
フリーのバックエンドエンジニア。DB周り、table設計とか。 \

プロジェクトの火消しやったりとか。 \
[twitter: @k_otogawa](https://twitter.com/k_otogawa)

前置きすると、
今回説明するのは、ファイルの最後に改行入れるとか、タブはスペース4個分とか。
一般的な意味のコーディング規約という意味じゃないです。
bashにはこういう問題があるから、それを解決する手段として
こういう書き方をするのはどうですか？という一つの提案です。

## bashの問題点

簡単に属人化する

自分は色々なところ参加させていただいているのですが、
bashは割とこれが起きることが多いです。

そもそも属人化はなんで起きるのかというと、
自分は次にあげる理由のせいだと思っています。

## 属人化の原因

1. メンバーの勉強コストが高い状態にしている
2. 書いた人でないとトラブル解決が遅い。

これらの原因を解決するためにはどういう
コーディング方針が必要かというと、
次の方針にしたら解決できるのではないでしょうか。

## コーディング方針

1. 明示しろ考えさせるな
2. awkやループを使うな

なんでこれで属人化の原因が解消できるかという
説明をしていきます。

### 明示しろ。考えさせるな

明示したら何がいいかというと。

1. 突然勉強会が始まるのを防げる

ここで言う勉強会はどういうことかというと、
他の人が読めないから、これってどういう意味とか、
この処理わからんとか他の人に聞くことを言っています。

なぜこれが起きるかというと、わかりづらい書き方や曖昧な書き方だから。

この状態だと、そこそこ急ぎだったらその人しかできない。
というケースが多発します。これを防げる。

まだ、プログラミング言語だったら、vscodeの
インテリセンスがすごく賢いので、
このオブジェクトはこう言う意味で、こう言うプロパティがあるから
とか表示してくれるし、
曖昧な書き方や、これはちょっと...と思う書き方は
linterで防げます。

bashはエディタのインテリセンスが貧弱だし、
メジャーなlinterやtestも無いから、それで防ぐのは厳しい。

特に速度的な差もないし、修正のしやすさも変わらないなら、
明示して曖昧な書き方をなくしたほうがいい。

2. 書いた本人以外でもトラブル解決を早くできる。減らせる

エンジニアが業務理解できていても、
bashがわかりづらい書き方してと読めないと、
書いた人連れてこないときついです。

これは業務的に見てもかなり危険なので、この状態作らないために
できるだけ多くのエンジニアが読みやすいように、明示した方がいい。

### 要点として

要点としては、「明示しろ」というのは結局はソースコードによって
コミュニケーションコストを減らそうぜ！それによって属人化減らそうぜ!という話です。

## awkやループ使うな

ループには欠点がある

1. ループ内には複数の意味を持った処理が入りがちになる
2. ループ回数で変数の状態が変わる

これ欠点なの？とか話になると思うんですが、

特定の処理だけ切り離して、実行してみるって言うのが難しくなります。
ループ内にある今自分が直したい処理と、他の処理がお互い影響しあう。
それと合わせて変数が正しい動きをしているかっていうのを確認する必要がある。

Javaでいうとeclipseのデバッガ使ってループ内のバグ直すために
ステップ実行使って値確認してっていうそういう手段取れないときついです。

その結果どうなるかというと、

## awkやループ使うな2

1. デバッグが難しくなる

では、なぜわざわざbashでループ使っているかっていうと、
変数の状態の違いにより、ifとかcaseとかの制御文で
処理を分けたいっていう狙いがあるケースがあるわけなんですけど、
これも書き方次第ではループを無くすこともできる。

2. 再利用できるとは

次は再利用についてですが、
どういう風にしたらbashを再利用できるか？
っていうと、次のことしたらできることだと思っています。

1. 簡単に関数に切り出せる
2. 対話形式で実行できる
3. 変数名や、オプションなど最低限のものだけ変更したら動く

これやってると何がいいかというと。
何々さんこれちょっとやってもらっていい？
50行目から60業目のやつ参考になると思うから
コピペして、コマンド変えたらできると思う。
わからんかったら聞いて。

こういう風に簡単に運用できるっていうのがいいと思っています。

ビジネスでよく横展開できるかっていうけど、これも小さい意味では
横展開だと自分は思ってて、これをできるだけ増やしたい。

## 要点として

要点としては、awkやループ使うなっていうのは、
使わないことによって、
ソースコードの運用と品質管理を楽にすることにより
属人化を防ごうということです。

たいていの場合は、コマンドとパイプの組み合わせで、
ループ処理が隠蔽できるから、書かなくていいことが多いと思います。

どうしても書いたほうが管理楽とかだったら書いてください。

### じゃあどうするか？っていうと

なぜループを使うかというと、これとifやcaseみたいな条件文と
一緒に描く時があって、特定の値の時に違う処理を書きたいから。

## ここまでの主張まとめ

bashには属人化の問題がある。
属人化の原因

1. メンバーの勉強コストが高い状態にしている
2. 書いた人でないとトラブル解決が遅い。

と考えます。

## ここまでの主張まとめ2

次のコーディング方針で対処できそうです。

1. 明示しろ考えさせるな
2. awkやループを使うな

問題がわかった、原因もわかった。対処法もだいたいわかった。
ということで、
これをソースコードに具体的にどうやって落とすのか？
という話をします。

## 具体的なソースコード仕様

例えば、hddの使用率が一定以上の値だったら、
csv形式でリストで表示するというスクリプトを書きたい。
とします。

そしてそれは
これはdfコマンド使ったら書けそう。

例えばdf -h実行して、
(vagrant 上で実行)

このUSEDが指定の値以上の行だけ、表示するコマンドを

## ダメなソースコード

まず、ダメなソースコードから説明します。

1. set -e またはset -eu

とりあえず、おまじないとして書いてあるプロジェクト
めっちゃ多いんですが、これはエラーが発生したらそのエラーコードで
returnするという意味で、これ書いてあるから、関数内で
チェックが甘いっていうプロジェクトはすっごく多いです。

set -eの何が問題かというと、
ソースコードを書き換えるたびにエラーで終了する場所が変わるのに、
エラーが出る可能性がある場所が明示されていないから、
ソースの流れをみて初めてどこでエラーが出そうかわかるので、デバッグの難易度が上がる。

こういうプロジェクトは大抵エラー時の復帰処理や、出力を関数内に隠蔽してないから、
エラー処理を関数の呼び出し元でやる必要があります。

そうすると関数の呼び出し元がいろんなところにある場合は、
エラー時の処理がいろんなところに散るということです。
これはメンテナンス上よくなくて、簡単に属人化します。
特に運用時にきつい。

そもそも論として、
たいていのプログラムはコマンド実行前に失敗するかどうか明確に決まっていて、
エラーが起きる可能性がある場所を明示させています。

例えばJavaだったら、一部の関数はtry catchしてくれないとビルドの時エラーになります。
なぜかというと、その関数は失敗するとやばいから、
できるだけ処理してほしいし、ここはエラーがでるかもと明示してほしいから。

その書き方にbashも従ったほうがいいと私は考えます。

bashはバックアップ取ったり、データの同期取ったり、
osの統計情報の監視をしたりという処理を書きます。
割と失敗できない処理が多いから、
雑にエラー起きたらそこで終了という設定をしないほうがいいです。

例えば、csvファイル見て何行かは処理したい、
特定の行えラーでもそこで止めず、とりあえず進めたい。

とかでも結局エラーの場所っていうのは明示したほうが
デバッグとメンテナンスが楽です。

さらにset -eがダメな理由を追加すると
bashの変数の展開にも関わってきます。

次のページなんですけど、
これら見た時にどういう意味だと思いますか？

## 難解な変数展開

a. ${!var}, b.  ${var:?}, c. ${var?}

a,b,cはそれぞれどのような動きをとると思いますか？

tsとかswiftとかプログラミング言語なら
?だったら、null返してそのまま処理進む、
!だったら、エラー処理しない限り終了。

実行時どのように処理されるか？

1. setのオプションに関わらず、変数が空、未定義の場合、変数展開時にエラーが起き処理は進む。
2. setのオプションに関わらず、変数が空、未定義の場合、変数展開時にエラーが起き元の場所にreturn。
3. setのオプションの値を見て初めて決まる。
4. setのオプションに関わらず、変数が空、未定義でもエラーは起きない。処理は進む。

## 難解な変数展開2

5. この中に答えはない。
6. 変数が空、未定義の場合、変数展開時にエラーが起きる。その後の処理がどうなるかはset次第。
7. 変数が未定義の場合、変数展開時にエラーが起きる。その後の処理がどうなるかはset次第。
8. 変数の値が0以外の数字、空、未定義の場合0を返し、それ以外の値の場合は値をそのまま返す。


プログラミング言語でいう
emptyか、異常値の場合は真に相当する値を返しそうじゃなかったら、変数の値を返すということ。
jsとかphpならそれっぽい、関数を書く人は割といると思います。

ちょっと軽く考えてみてください。

## 難解な変数展開3

aは5です答えないです。

関節展開という表記で、変数の中身を見てそれと同じ文字列の変数の値を表示する
っていう処理です。

bは6です。空と未定義の変数の場合はエラーです。
cは7です。未定義の変数の場合はエラーになります。

結局set次第ということなんですけれども、

set -eだったら、b,cの書き方はプログラミング言語でいう!だし、
set使ってなかったら、?と似た感覚の処理になる。

同じ表記でもプログラミング言語で言う、!か?かが変わる。
っていうことです。

これはちょっと直感的な動きとは思えなくて、できるだけ
明示したいという方針に反します。

だから?という表記は使わない。

ちなみにset -uっていうオプションがあってこれは未定義の変数を展開したときに、
エラーが発生するというオプションです。
つまり、set -uを使ったところで、bの書き方もcの書き方も
結果変わりません。

それだったら、未定義の変数をエラーにしたい時にはb,cの書き方だけ
すべきであってset -uを使ってすべての未定義の変数展開、参照を
エラーにする必要はないはずなんです。

set -eも set -uも良くないという話したんですが、
両方使うset -euってのはもっと良くなくて、
変数の状態によって、分岐処理がある
ということを明示できないんですよ。

どういうことかいうと、
(見せる)

次の処理考えるといいと思うんですが、

これは変数が未定義か、空だったら自然な処理だけどこれ書けないって

それでも、
どこでエラーが発生するかわからないから、とりあえずset -e使うんだっていう人
いると思うんですけど、それはtrapで防げるはずです。

trapって特定の処理、
関数からリターンしたときとかエラーがあったときとかありますけど。
どこで発生するかわからないというのは
大抵trapに吸収させることができるはずなんでそっち使ってください。

エラーが発生したらtrapする。感じのものtrapを書いたらいいはず。

例としてどんなのがあるかというと、
(見せる)

これはどう言う処理かというと、エラーが発生したら、ダブルクォーテーション内の処理をするという
処理を登録するコマンドで、echoでerror internalと表示させて、
その次にtrap - ERR エラーの登録を解除してあげて、その後exitして
関数を抜けるという処理です。
trap - ERRは関数の呼び出し元とプロセス違うなら、別に書かなくていいんですけど、
sourceコマンドみたいに同じプロセスでやるなら必須になります。
いちいち考えるの面倒臭いので、決まり文句として書いてあげるといいと思います。

こんな感じで処理してやったらいけるはずです。

結局ちゃんとしたエラー処理するなら、set -eでもtrap使って
このように書くことになります。

同じ要領で、エラー処理した後に通常の後始末処理してから、
関数を抜けたい。
という場合はこのようにかけます。

これはどう言う処理かというと、
まず、とりあえず、エラー処理をして、その中で、
関数を抜けるためにreturn処理をしています。

でreturn の処理の中で通常の関数を抜けるときの後始末の処理をしている
という作りです。

これだったら、ちゃんとエラー処理明示されているし、
運用も別に難しくないと思います。

唯一気を付ける点としてはsourceコマンドで
呼び出した場合は既存の同じtrapを上書きしてしまうというリスクがあるので
それには注意。
ただ、sourceコマンドでtrap上書きしてしまうなら、
大抵設計がおかしいと思うので、見直してください。

話をset -eに戻します。
じゃあ今まで俺たちが先輩に絶対書けと言われて書いてきたset -euって何？
っていう話になる。
たいていの場合は特に意味ないと思います。

こっからは私の推測の話なんですが、

set -e ってソースコードを自動生成する時ようのオプションなんじゃないかなって
世の中には読めるけど、人間が触っちゃダメなファイルってあると思うんですよ。
bashから設定ファイルを生成するとかそういうソースコードの場合。
一番わかりやすい例がgrubの設定。
bashで書いてあって、それをコマンド実行して設定ファイルを作っているんですよ。
grubで設定ファイルを生成するときに、異常がある設定ファイルで上書き
しない作りにしたいから。

実際grubの設定ファイル見せますと、
(見せる)

このbashのスクリプト自体が自動生成されているから、人が直接
触ることないんですよ。
grub自体にバグがあって、自動生成されているスクリプトがおかしいときは
何がなんでも弾きたい。
そういう作りにするんなら、エラーは全部異常終了にしたほうがいいよね？
という考え方です。

たいていのバッチ処理は人間が触ること前提だし、エラー起きても、
エラー以外のところは処理したいとか普通にあるから、
大した理由ないのにいじるべきでない。

2. オプションを必要無いのに変数に分けない

これを見た瞬間にオプションを動的に追加したり、減らしたりするのかな？
もしくは今後そういう処理が追加される予定があるのか？
という疑問が生まれるんですよ。
そういう曖昧さを消したい。

動的にしたいとしても、
例えば、rsyncでdry-runしたい場合とか、

if [ -z $frewr ]; then
    dry_run="--dry-run"
fi

rsync -av ./ /path/to/disk $dry_run
一部追加するとかそういうぐらいで、


3. ループ使わない


加えて、
なんでこの人awk使わないか?というとこれは
厳密にはスペース区切りのデータじゃないので、awkで綺麗に分割できない。
Mounted on
で一つのカラムだから、カラムにスペース入ってくると面倒臭いことになる。

だから、


## じゃあお前の言う書き方

## 

## 結論

1. 明示しろ考えさせるな
2. awkやループをあまり使うな

難しい処理を描くコツとしては
検索ロジック、表示ロジック

アタリをつける。
一度で全てやろうとしない。


ここら辺のコストを運用エンジニアや、後輩が背負うことになるから。
ただ、ソースコード書けました!っていうレベルじゃないし、
もっと他のメンバーがソースコード書けないのは自分のせいにしたほうがいいという話です。

ループを入れるとループ全体としてどうか？
を追わないといけないけど、

パイプで繋げていった場合はコマンドの意味を追っていったら、
必ず、やりたいことが出るようになっている。

一定以上難しい、
愚直に一回でやろうとするとループが発生するもので
ループを避けるコツとしては
検索ロジックと、
結論や表示のロジックを分けることです。

できるだけ、エンジニアに業務理解や、事業としてどうしたいかと
今のシステム的にどうなのか？がどれぐらいかけ離れているかの理解に頭使って欲しい。
