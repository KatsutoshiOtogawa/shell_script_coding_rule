# シニアエンジニアのためのbashコーディング規約

---

title: シニアエンジニアのためのbashコーディング規約
author: KatusothiOtogawa
date: 2022-03-19

---

## 自己紹介

音川 勝俊 \
フリーのバックエンドエンジニア。DB周り、table設計とか。 \

プロジェクトの火消しやったりとか。 \
[twitter: @k_otogawa](https://twitter.com/k_otogawa)

前置きすると、
今回説明するのは、ファイルの最後に改行入れるとか、タブはスペース4個分とか。
一般的な意味のコーディング規約という意味じゃないです。
bashにはこういう問題があるから、それを解決する手段として
こういう書き方をするのはどうですか？という一つの提案です。

## bashの問題点

簡単に属人化する

自分は色々なところ参加させていただいているのですが、
bashは割とこれが起きることが多いです。

そもそも属人化はなんで起きるのかというと、
自分は次にあげる理由のせいだと思っています。

## 属人化の原因

1. メンバーの勉強コストが高い状態にしている
2. 書いた人でないとトラブル解決が遅い。

これらの原因を解決するためにはどういう
コーディング方針が必要かというと、
次の方針にしたら解決できるのではないでしょうか。

## コーディング方針

1. 明示しろ考えさせるな
2. awkやループを使うな

なんでこれで属人化の原因が解消できるかという
説明をしていきます。

### 明示しろ。考えさせるな

明示したら何がいいかというと。

1. 突然勉強会が始まるのを防げる

ここで言う勉強会はどういうことかというと、
他の人が読めないから、これってどういう意味とか、
この処理わからんとか他の人に聞くことを言っています。

なぜこれが起きるかというと、わかりづらい書き方や曖昧な書き方だから。

この状態だと、そこそこ急ぎだったらその人しかできない。
というケースが多発します。これを防げる。

まだ、プログラミング言語だったら、vscodeの
インテリセンスがすごく賢いので、
このオブジェクトはこう言う意味で、こう言うプロパティがあるから
とか表示してくれるし、
曖昧な書き方や、これはちょっと...と思う書き方は
linterで防げます。

bashはエディタのインテリセンスが貧弱だし、
メジャーなlinterやtestも無いから、それで防ぐのは厳しい。

特に速度的な差もないし、修正のしやすさも変わらないなら、
明示して曖昧な書き方をなくしたほうがいい。

2. 書いた本人以外でもトラブル解決を早くできる。減らせる

エンジニアが業務理解できていても、
bashがわかりづらい書き方してと読めないと、
書いた人連れてこないときついです。

これは業務的に見てもかなり危険なので、この状態作らないために
できるだけ多くのエンジニアが読みやすいように、明示した方がいい。

### 要点として

要点としては、「明示しろ」というのは結局はソースコードによって
コミュニケーションコストを減らそうぜ！それによって属人化減らそうぜ!という話です。

## awkやループ使うな

ループには欠点がある

1. ループ内には複数の意味を持った処理が入りがちになる
2. ループ回数で変数の状態が変わる

これ欠点なの？とか話になると思うんですが、

特定の処理だけ切り離して、実行してみるって言うのが難しくなります。
ループ内にある今自分が直したい処理と、他の処理がお互い影響しあう。
それと合わせて変数が正しい動きをしているかっていうのを確認する必要がある。

Javaでいうとeclipseのデバッガ使ってループ内のバグ直すために
ステップ実行使って値確認してっていうそういう手段取れないときついです。

その結果どうなるかというと、

## awkやループ使うな2

1. デバッグが難しくなる

では、なぜわざわざbashでループ使っているかっていうと、
変数の状態の違いにより、ifとかcaseとかの制御文で
処理を分けたいっていう狙いがあるからやっているわけです。

これも書き方次第ではループを無くすことができたり、
ループを使うとしても簡単に、直感的に書くことができます。

2. 再利用できるとは

次は再利用についてですが、
どういう風にしたらbashを再利用できるか？
っていうと、次のことしたらできることだと思っています。

1. 簡単に関数に切り出せる
2. 対話形式で実行できる
3. 変数名や、オプションなど最低限のものだけ変更したら動く

これやってると何がいいかというと。
何々さんこれちょっとやってもらっていい？
50行目から60業目のやつ参考になると思うから
コピペして、コマンド変えたらできると思う。
わからんかったら聞いて。

こういう風に簡単に運用できるっていうのがいいと思っています。

ビジネスでよく横展開できるかっていうけど、これも小さい意味では
横展開だと自分は思ってて、これをできるだけ増やしたい。

## 要点として

要点としては、awkやループ使うなっていうのは、
使わないことによって、
ソースコードの運用と品質管理を楽にすることにより
属人化を防ごうということです。

たいていの場合は、コマンドとパイプの組み合わせで、
ループ処理が隠蔽できるから、書かなくていいことが多いと思います。

どうしても書いたほうが管理楽とかだったら書いてください。

### じゃあどうするか？っていうと

なぜループを使うかというと、これとifやcaseみたいな条件文と
一緒に描く時があって、特定の値の時に違う処理を書きたいから。

## ここまでの主張まとめ

bashには属人化の問題がある。
属人化の原因

1. メンバーの勉強コストが高い状態にしている
2. 書いた人でないとトラブル解決が遅い。

と考えます。

## ここまでの主張まとめ2

次のコーディング方針で対処できそうです。

1. 明示しろ考えさせるな
2. awkやループを使うな

問題がわかった、原因もわかった。対処法もだいたいわかった。
ということで、
これをソースコードに具体的にどうやって落とすのか？
という話をします。

## 具体的なソースコード仕様

例えば、hddの使用率が一定以上の値だったら、
csv形式でリストで表示するというスクリプトを書きたい。
とします。

そしてそれは
これはdfコマンド使ったら書けそう。

例えばdf -h実行して、
(vagrant 上で実行)

このUSEDが指定の値以上の行だけ、表示するコマンドを

## ダメなソースコード

まず、ダメなソースコードから説明します。

1. set -e またはset -eu

とりあえず、おまじないとして書いてあるプロジェクト
めっちゃ多いんですが、これはエラーが発生したらそのエラーコードで
returnするという意味で、これ書いてあるから、関数内で
チェックが甘いっていうプロジェクトはすっごく多いです。

set -eの何が問題かというと、
ソースコードを書き換えるたびにエラーで終了する場所が変わるのに、
エラーが出る可能性がある場所が明示されていないから、
ソースの流れをみて初めてどこでエラーが出そうかわかるので、デバッグの難易度が上がる。

こういうプロジェクトは大抵エラー時の復帰処理や、出力を関数内に隠蔽してないから、
エラー処理を関数の呼び出し元でやる必要があります。

そうすると関数の呼び出し元がいろんなところにある場合は、
エラー時の処理がいろんなところに散るということです。
これはメンテナンス上よくなくて、簡単に属人化します。
特に運用時にきつい。

そもそも論として、
たいていのプログラムはコマンド実行前に失敗するかどうか明確に決まっていて、
エラーが起きる可能性がある場所を明示させています。

例えばJavaだったら、一部の関数はtry catchしてくれないとビルドの時エラーになります。
なぜかというと、その関数は失敗するとやばいから、
できるだけ処理してほしいし、ここはエラーがでるかもと明示してほしいから。

その書き方にbashも従ったほうがいいと私は考えます。

bashはバックアップ取ったり、データの同期取ったり、
osの統計情報の監視をしたりという処理を書きます。
割と失敗できない処理が多いから、
雑にエラー起きたらそこで終了という設定をしないほうがいいです。

例えば、csvファイル見て何行かは処理したい、
特定の行えラーでもそこで止めず、とりあえず進めたい。

とかでも結局エラーの場所っていうのは明示したほうが
デバッグとメンテナンスが楽です。

さらにset -eがダメな理由を追加すると
bashの変数の展開にも関わってきます。

次のページなんですけど、
これら見た時にどういう意味だと思いますか？

## 難解な変数展開

a. ${!var}, b.  ${var:?}, c. ${var?}

a,b,cはそれぞれどのような動きをとると思いますか？

tsとかswiftとかプログラミング言語なら
?だったら、null返してそのまま処理進む、
!だったら、エラー処理しない限り終了。

実行時どのように処理されるか？

1. setのオプションに関わらず、変数が空、未定義の場合、変数展開時にエラーが起き処理は進む。
2. setのオプションに関わらず、変数が空、未定義の場合、変数展開時にエラーが起き元の場所にreturn。
3. setのオプションの値を見て初めて決まる。
4. setのオプションに関わらず、変数が空、未定義でもエラーは起きない。処理は進む。

## 難解な変数展開2

5. この中に答えはない。
6. 変数が空、未定義の場合、変数展開時にエラーが起きる。その後の処理がどうなるかはset次第。
7. 変数が未定義の場合、変数展開時にエラーが起きる。その後の処理がどうなるかはset次第。
8. 変数の値が0以外の数字、空、未定義の場合0を返し、それ以外の値の場合は値をそのまま返す。


プログラミング言語でいう
emptyか、異常値の場合は真に相当する値を返しそうじゃなかったら、変数の値を返すということ。
jsとかphpならそれっぽい、関数を書く人は割といると思います。

ちょっと軽く考えてみてください。

## 難解な変数展開3

aは5です答えないです。

関節展開という表記で、変数の中身を見てそれと同じ文字列の変数の値を表示する
っていう処理です。

bは6です。空と未定義の変数の場合はエラーです。
cは7です。未定義の変数の場合はエラーになります。

結局set次第ということなんですけれども、

## 難解な変数展開4

set -eだったら、b,cの書き方はプログラミング言語でいう!だし、
set使ってなかったら、?と似た感覚の処理になる。

同じ表記でもプログラミング言語で言う、!か?かが変わる。
っていうことです。

これはちょっと直感的な動きとは思えなくて、できるだけ
明示したいという方針に反します。

だから?という表記は使わない。

ここでさらに思い出して欲しいのが、
未定義の変数をエラーにするやつset -uってあったと思うんですけど、アレなんだったんでしょう？
未定義の変数を展開次にエラーにする構文あるなら意味なく無い？未定義は弾けても、空の変数弾けないなら影響範囲広いだけでメンテナンス性悪いだけじゃない？
って言う疑問あると思います。
メリットがあるのか？

## set -uを使うメリット

bashでは特にメリットないです。

何らかの理由でどうしても使わないといけない、という要件があっても関数内でsetの設定を閉じたら良いと思います。
そもそも論として?にしても:?にしてもset -uにしてもそれらと同じように空の変数と未定義の変数を弾けて、なおかつ直感的な方法があったはずです。

## -z 変数

空の文字列も未定義の変数も対処できる。直感的

-z 変数という形で未定義、空の変数を処理出来るはず。
エラー処理したかったらここで処理してreturnしたらいいし、

結局、関数内でちゃんと処理するなら、if書く事になるから、
文法のバリエーションを無駄に増やしてメンバーの学習コスト上げる必要は無い。

### 補足

set -eも set -uも良くないという話したんですが、
両方使うset -euってのはもっと良くなくて、
変数の状態によって、分岐処理がある
ということを明示できないんですよ。

どういうことかいうと、
(見せる)

次の処理考えるといいと思うんですが、

これは変数が未定義か、空だったら自然な処理だけどこれ書けないって

それでも、
どこでエラーが発生するかわからないから、とりあえずset -e使うんだっていう人
いると思うんですけど、それはtrapで防げるはずです。

trapって特定の処理、
関数からリターンしたときとかエラーがあったときとかありますけど。
どこで発生するかわからないというのは
大抵trapに吸収させることができるはずなんでそっち使ってください。

エラーが発生したらtrapする。感じのものtrapを書いたらいいはず。

例としてどんなのがあるかというと、
(見せる)

これはどう言う処理かというと、エラーが発生したら、ダブルクォーテーション内の処理をするという
処理を登録するコマンドで、echoでerror internalと表示させて、
その次にtrap - ERR エラーの登録を解除してあげて、その後exitして
関数を抜けるという処理です。
trap - ERRは関数の呼び出し元とプロセス違うなら、別に書かなくていいんですけど、
sourceコマンドみたいに同じプロセスでやるなら必須になります。
いちいち考えるの面倒臭いので、決まり文句として書いてあげるといいと思います。

こんな感じで処理してやったらいけるはずです。

結局ちゃんとしたエラー処理するなら、set -eでもtrap使って
このように書くことになります。

同じ要領で、エラー処理した後に通常の後始末処理してから、
関数を抜けたい。
という場合はこのようにかけます。

これはどう言う処理かというと、
まず、とりあえず、エラー処理をして、その中で、
関数を抜けるためにreturn処理をしています。

でreturn の処理の中で通常の関数を抜けるときの後始末の処理をしている
という作りです。

これだったら、ちゃんとエラー処理明示されているし、
運用も別に難しくないと思います。

唯一気を付ける点としてはsourceコマンドで
呼び出した場合は既存の同じtrapを上書きしてしまうというリスクがあるので
それには注意。
ただ、sourceコマンドでtrap上書きしてしまうなら、
大抵設計がおかしいと思うので、見直してください。

話をset -eに戻します。
じゃあ今まで俺たちが先輩に絶対書けと言われて書いてきたset -euって何？
っていう話になる。
たいていの場合は特に意味ないと思います。

こっからは私の推測の話なんですが、

set -e ってソースコードを自動生成する時ようのオプションなんじゃないかなって
世の中には読めるけど、人間が触っちゃダメなファイルってあると思うんですよ。
bashから設定ファイルを生成するとかそういうソースコードの場合。
一番わかりやすい例がgrubの設定。
bashで書いてあって、それをコマンド実行して設定ファイルを作っているんですよ。
grubで設定ファイルを生成するときに、異常がある設定ファイルで上書き
しない作りにしたいから。

実際grubの設定ファイル見せますと、
(見せる)

このbashのスクリプト自体が自動生成されているから、人が直接
触ることないんですよ。
grub自体にバグがあって、自動生成されているスクリプトがおかしいときは
何がなんでも弾きたい。
そういう作りにするんなら、エラーは全部異常終了にしたほうがいいよね？
という考え方です。

たいていのバッチ処理は人間が触ること前提だし、エラー起きても、
エラー以外のところは処理したいとか普通にあるから、
大した理由ないのにいじるべきでない。

2. オプションを必要無いのに変数に分けない

これを見た瞬間にオプションを動的に追加したり、減らしたりするのかな？
もしくは今後そういう処理が追加される予定があるのか？
という疑問が生まれるんですよ。
そういう曖昧さを消したい。

動的にしたいとしても、
(見せる)
例えば、rsyncでdry-runしたい場合とか、

```bash
if [ -z $frewr ]; then
    dry_run="--dry-run"
fi
```

rsync -av ./ /path/to/disk $dry_run

一部追加するとかそういうぐらいであまり、
オプションの値をガチャガチャいじるってのはないと思うので、
必要ないのにオプションを変数に分けないでください。

3. ループ使わない

さっきも言ったループ使わないというところなんですが、
df -h ってcsv形式のデータなのに何でこの人awk使わないか?というとこれは
厳密にはスペース区切りのデータじゃないので、awkで綺麗に分割できない。
Mounted on
で一つのカラムだから、カラムにスペース入ってくると面倒臭いことになる。

だから、

## じゃあ具体的にどういう書き方したら良いか

実処理を呼び出す関数をちゃんと作って、
最初に値のチェックをしてあげて、

その後まず、表示に必要な行の場所だけあたりをつけておきます。
なぜ、これをやるかと言うと、sedで表示するにしても、
grepで表示するにしても、行にある特定の値の状態を見て
表示するっていうのは無理だから、一度使用率の値的に表示する
ものだけリストで取得する。

awkやループ使わないって言ったけど、
そもそも、いろんな状態が入ってたり、変数の値がコロコロ変わるから
嫌っているだけで、数字だけの列にして、
値だけの比較にしたら、簡単に処理できるから、
こんな形だったら導入してもいいかなと。

その後そのリストを使って表示

それを呼び出す外部からのエントリーポイントとして
main関数という形で分けます。

まず、こう言う感じのmain関数を定義します。
ここでデバッグの引数

実際処理している行数は倍ぐらいになっているけど、
こちらの方がメンテナンス楽になっていると思います。

## 結論1

1. 明示しろ考えさせるな
2. awkやループをあまり使うな

## 結論2

ループが発生しそうになったら

1. 検索ロジックとそれ以外を分けて考えてみる。
2. 一時ファイルに途中の処理を分ける。
3. 一度で全部しようとしない

これらを試してみて、ダメそうならループも視野に入れる。

ループを入れるとループ全体としてどうか？
を追わないといけないけど、

パイプで繋げていった場合はコマンドの意味を追っていったら、
必ず、やりたいことが出るようになっている。
